<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Fusion">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#1a1a2e">
    <title>Fusion 7 - Design</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { 
            height: 100%; 
            overflow: hidden;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, sans-serif; 
            background: #1a1a2e; 
            min-height: 100vh;
            min-height: -webkit-fill-available;
            display: flex;
            align-items: center; 
            justify-content: center; 
            color: white;
            padding: 5px;
        }
        
        .main-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-evenly;
            width: 100%;
            height: 100%;
            gap: 10px;
        }
        
        @media (orientation: landscape) {
            .main-container { flex-direction: row; }
            .game-area { width: min(42vw, 85vh) !important; height: min(42vw, 85vh) !important; }
            .menu-panel { max-height: 90vh; overflow-y: auto; }
        }
        
        @media (orientation: portrait) {
            .game-area { width: min(85vw, 42vh) !important; height: min(85vw, 42vh) !important; }
        }
        
        .menu-btn {
            position: fixed; 
            top: max(8px, env(safe-area-inset-top)); 
            right: max(8px, env(safe-area-inset-right));
            width: 44px; height: 44px;
            background: rgba(255,215,0,0.9);
            border: none; border-radius: 12px;
            cursor: pointer; z-index: 1001;
            display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 5px;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }
        .menu-btn span { display: block; width: 24px; height: 3px; background: #1a1a2e; transition: 0.3s; border-radius: 2px; pointer-events: none; }
        .menu-btn.open { background: rgba(255,100,100,0.9); }
        .menu-btn.open span:nth-child(1) { transform: rotate(45deg) translate(5px, 6px); }
        .menu-btn.open span:nth-child(2) { opacity: 0; }
        .menu-btn.open span:nth-child(3) { transform: rotate(-45deg) translate(5px, -6px); }
        
        .menu-panel {
            position: fixed; 
            top: calc(max(8px, env(safe-area-inset-top)) + 50px); 
            right: max(8px, env(safe-area-inset-right));
            background: rgba(20, 20, 40, 0.98); 
            border-radius: 16px; padding: 12px;
            z-index: 1000; display: none; flex-direction: column; gap: 5px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.7);
            min-width: 280px;
            max-height: 90vh;
            overflow-y: auto;
            touch-action: manipulation;
            border: 1px solid rgba(255,215,0,0.3);
        }
        .menu-panel.open { display: flex; }
        .menu-panel h3 { color: #ffd700; font-size: 0.8em; margin: 8px 0 4px 0; border-bottom: 1px solid rgba(255,215,0,0.2); padding-bottom: 3px; }
        .menu-row { display: flex; align-items: center; gap: 6px; min-height: 28px; }
        .menu-row label { font-size: 0.65em; min-width: 75px; color: #ccc; }
        .menu-row .value { font-size: 0.65em; min-width: 40px; color: #ffd700; text-align: right; font-family: monospace; }
        
        .menu-row input[type="range"] { 
            flex: 1; height: 24px;
            -webkit-appearance: none; background: transparent;
            touch-action: manipulation;
        }
        .menu-row input[type="range"]::-webkit-slider-runnable-track { height: 6px; background: rgba(255,255,255,0.2); border-radius: 3px; }
        .menu-row input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; background: linear-gradient(135deg, #ffd700, #ffa500); border-radius: 50%; margin-top: -7px; box-shadow: 0 2px 4px rgba(0,0,0,0.4); }
        
        .toggle-switch { position: relative; width: 40px; height: 22px; touch-action: manipulation; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .toggle-slider { position: absolute; cursor: pointer; inset: 0; background-color: rgba(255,255,255,0.25); border-radius: 22px; }
        .toggle-slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 3px; bottom: 3px; background-color: white; border-radius: 50%; transition: 0.2s; box-shadow: 0 2px 4px rgba(0,0,0,0.3); }
        input:checked + .toggle-slider { background: linear-gradient(135deg, #ffd700 0%, #ffa500 100%); }
        input:checked + .toggle-slider:before { transform: translateX(18px); }
        
        .menu-btn-action { padding: 8px 12px; font-size: 0.7em; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; touch-action: manipulation; -webkit-tap-highlight-color: transparent; }
        .menu-btn-action.play-btn { background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); }
        .menu-btn-action.play-btn.active { background: linear-gradient(135deg, #f5576c 0%, #f093fb 100%); }
        
        .game-container { background: #ffffff; border-radius: 50%; box-shadow: 0 5px 25px rgba(0,0,0,0.4); touch-action: none; }
        .game-container.dark { background: #2a2a3e; }
        .game-area { position: relative; background: #ffffff; border-radius: 50%; overflow: visible; touch-action: none; }
        .game-area.dark { background: #2a2a3e; }
        .ring { position: absolute; border-radius: 50%; top: 50%; left: 50%; pointer-events: none; border-style: dashed; border-color: rgba(80,80,80,0.4); }
        .dark .ring { border-color: rgba(200,200,200,0.3); }
        .triangle-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1; }
        
        .sun-reactor {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #fff8e0 0%, #ffd700 30%, #ff8c00 70%, #ff4500 100%);
            box-shadow: 
                0 0 40px rgba(255,215,0,0.8),
                0 0 80px rgba(255,165,0,0.5),
                inset 0 0 30px rgba(255,255,255,0.4);
            z-index: 50;
            pointer-events: none;
            overflow: hidden;
            display: none;
        }
        .sun-reactor.visible { display: block; }
        .sun-reactor::before {
            content: '';
            position: absolute;
            width: 120%; height: 120%;
            top: -10%; left: -10%;
            background: radial-gradient(circle, transparent 30%, rgba(255,200,0,0.3) 70%);
            animation: sunPulse 3s ease-in-out infinite;
        }
        @keyframes sunPulse {
            0%, 100% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(1.05); opacity: 0.8; }
        }
        
        .sun-reactor.wave { animation: sunWave 0.5s ease-out; }
        @keyframes sunWave {
            0% { transform: translate(-50%, -50%) scale(1); }
            30% { transform: translate(-50%, -50%) scale(1.15); }
            60% { transform: translate(-50%, -50%) scale(0.95); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }
        
        .moon-reactor {
            background: radial-gradient(circle at 30% 30%, #e8f0ff 0%, #a8c0ff 30%, #6080c0 70%, #304080 100%);
            box-shadow: 
                0 0 40px rgba(168,192,255,0.8),
                0 0 80px rgba(100,128,192,0.5),
                inset 0 0 30px rgba(255,255,255,0.3);
        }
        .moon-reactor::before {
            background: radial-gradient(circle, transparent 30%, rgba(150,180,255,0.3) 70%);
        }
        
        .number { 
            position: absolute; 
            border-radius: 50%; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            font-weight: bold; 
            box-shadow: 0 2px 6px rgba(0,0,0,0.3); 
            user-select: none; 
            z-index: 10; 
            pointer-events: auto; 
            cursor: grab;
            transition: opacity 0.15s;
        }
        .number.dragging { cursor: grabbing; }
        .number.entering-sun { 
            z-index: 5;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .number.ghost {
            pointer-events: none;
            z-index: 55;
            opacity: 0;
            box-shadow: 0 0 15px rgba(255,200,100,0.5);
            animation: ghostPulse 2s ease-in-out infinite;
        }
        @keyframes ghostPulse {
            0%, 100% { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
            50% { opacity: 0.35; transform: translate(-50%, -50%) scale(1.05); }
        }
        .dark .number.ghost {
            box-shadow: 0 0 15px rgba(150,180,255,0.5);
        }
    </style>
</head>
<body>
    <button class="menu-btn" id="menuBtn"><span></span><span></span><span></span></button>
    
    <div class="menu-panel" id="menuPanel">
        <h3>üéÆ Jeu</h3>
        <div class="menu-row">
            <button id="playBtn" class="menu-btn-action play-btn">Play</button>
            <button id="resetBtn" class="menu-btn-action">Reset</button>
        </div>
        
        <h3>‚òÄÔ∏è Soleil</h3>
        <div class="menu-row">
            <label>Afficher:</label>
            <label class="toggle-switch"><input type="checkbox" id="showSun"><span class="toggle-slider"></span></label>
        </div>
        <div class="menu-row">
            <label>Diam√®tre:</label>
            <input type="range" id="sunSize" min="5" max="40" step="0.5" value="31">
            <span class="value" id="sunSizeVal">31.0%</span>
        </div>
        
        <h3>üîµ Couronne C1 (20)</h3>
        <div class="menu-row">
            <label>Limite ext:</label>
            <input type="range" id="limitC1Ext" min="40" max="50" step="0.5" value="50">
            <span class="value" id="limitC1ExtVal">50.0%</span>
        </div>
        <div class="menu-row">
            <label>Limite int:</label>
            <input type="range" id="limitC1Int" min="25" max="45" step="0.5" value="34.5">
            <span class="value" id="limitC1IntVal">34.5%</span>
        </div>
        <div class="menu-row">
            <label>Position:</label>
            <input type="range" id="posC1" min="-100" max="100" step="1" value="-48">
            <span class="value" id="posC1Val">-48%</span>
        </div>
        
        <h3>üü¢ Couronne C2 (10)</h3>
        <div class="menu-row">
            <label>Limite ext:</label>
            <input type="range" id="limitC2Ext" min="20" max="40" step="0.5" value="36.5">
            <span class="value" id="limitC2ExtVal">36.5%</span>
        </div>
        <div class="menu-row">
            <label>Limite int:</label>
            <input type="range" id="limitC2Int" min="10" max="35" step="0.5" value="18.5">
            <span class="value" id="limitC2IntVal">18.5%</span>
        </div>
        <div class="menu-row">
            <label>Position:</label>
            <input type="range" id="posC2" min="-100" max="100" step="1" value="-60">
            <span class="value" id="posC2Val">-60%</span>
        </div>
        
        <h3>‚≠ï Anneaux</h3>
        <div class="menu-row">
            <label>Afficher:</label>
            <label class="toggle-switch"><input type="checkbox" id="showRings" checked><span class="toggle-slider"></span></label>
        </div>
        <div class="menu-row">
            <label>√âpaisseur:</label>
            <input type="range" id="ringWidth" min="1" max="8" step="0.5" value="8">
            <span class="value" id="ringWidthVal">8.0px</span>
        </div>
        
        <h3>üî¢ Chiffres</h3>
        <div class="menu-row">
            <label>Taille:</label>
            <input type="range" id="numberSize" min="3" max="12" step="0.25" value="8">
            <span class="value" id="numberSizeVal">8.00%</span>
        </div>
        
        <h3>üé® Triangles</h3>
        <div class="menu-row">
            <label>Afficher:</label>
            <label class="toggle-switch"><input type="checkbox" id="showTriangles" checked><span class="toggle-slider"></span></label>
        </div>
        <div class="menu-row">
            <label>Opacit√©:</label>
            <input type="range" id="opacitySlider" min="5" max="100" step="1" value="20">
            <span class="value" id="opacityVal">20%</span>
        </div>
    </div>

    <div class="main-container" id="mainContainer">
        <div class="game-container">
            <div class="game-area" id="gameArea1">
                <canvas class="triangle-canvas" id="triangleCanvas1"></canvas>
                <div class="ring" id="ring1_1"></div>
                <div class="ring" id="ring1_2"></div>
                <div class="sun-reactor" id="sunReactor1"></div>
            </div>
        </div>
        <div class="game-container dark">
            <div class="game-area dark" id="gameArea2">
                <canvas class="triangle-canvas" id="triangleCanvas2"></canvas>
                <div class="ring" id="ring2_1"></div>
                <div class="ring" id="ring2_2"></div>
                <div class="sun-reactor moon-reactor" id="sunReactor2"></div>
            </div>
        </div>
    </div>

    <script>
        // === CONFIG CSS DYNAMIQUE ===
        var cssConfig = {
            sunSize: 0.31,        // Diam√®tre soleil
            limitC1Ext: 0.50,     // Limite externe C1
            limitC1Int: 0.345,    // Limite interne C1
            posC1: -0.48,         // Position dans zone C1 (-1 √† +1)
            limitC2Ext: 0.365,    // Limite externe C2
            limitC2Int: 0.185,    // Limite interne C2
            posC2: -0.60,         // Position dans zone C2 (-1 √† +1)
            ringWidth: 8,         // √âpaisseur anneaux en px
            numberSize: 0.08,     // Taille des chiffres
            opacity: 0.20         // Opacit√© triangles
        };
        
        var isPlaying = false, speed = 0.06, animationId = null;
        var crownsConfig = [
            {count: 20, step: 18, offset: 27},
            {count: 10, step: 36, offset: 18},
            {count: 5, step: 72, offset: 0}
        ];
        var colors = {c1bg:"#a8edea",c1txt:"#333333",c2bg:"#a8edea",c2txt:"#333333",c3bg:"#a8edea",c3txt:"#333333"};
        var matrices = [
            {id:1,canvasSize:550,cx:275,cy:275,globalRotation:0,offsets:[0,0,0],data:[[],[],[]],triangleCtx:null,hiddenInSun:[]},
            {id:2,canvasSize:550,cx:275,cy:275,globalRotation:0,offsets:[0,0,0],data:[[],[],[]],triangleCtx:null,hiddenInSun:[]}
        ];
        var activeTouches = {};
        var audioCtx = null;

        // === MENU ===
        document.getElementById('menuBtn').addEventListener('click', toggleMenu);
        document.getElementById('menuBtn').addEventListener('touchend', function(e) { e.preventDefault(); toggleMenu(); });
        document.getElementById('playBtn').addEventListener('click', togglePlay);
        document.getElementById('playBtn').addEventListener('touchend', function(e) { e.preventDefault(); togglePlay(); });
        document.getElementById('resetBtn').addEventListener('click', resetAll);
        document.getElementById('resetBtn').addEventListener('touchend', function(e) { e.preventDefault(); resetAll(); });
        
        // CSS Sliders
        document.getElementById('showSun').addEventListener('change', updateSunVisibility);
        document.getElementById('sunSize').addEventListener('input', updateCSSConfig);
        document.getElementById('limitC1Ext').addEventListener('input', updateCSSConfig);
        document.getElementById('limitC1Int').addEventListener('input', updateCSSConfig);
        document.getElementById('posC1').addEventListener('input', updateCSSConfig);
        document.getElementById('limitC2Ext').addEventListener('input', updateCSSConfig);
        document.getElementById('limitC2Int').addEventListener('input', updateCSSConfig);
        document.getElementById('posC2').addEventListener('input', updateCSSConfig);
        document.getElementById('showRings').addEventListener('change', updateRingsVisibility);
        document.getElementById('ringWidth').addEventListener('input', updateCSSConfig);
        document.getElementById('numberSize').addEventListener('input', updateCSSConfig);
        document.getElementById('showTriangles').addEventListener('change', function() { drawTriangles(0); drawTriangles(1); });
        document.getElementById('opacitySlider').addEventListener('input', updateCSSConfig);

        function toggleMenu() { document.getElementById("menuBtn").classList.toggle("open"); document.getElementById("menuPanel").classList.toggle("open"); }
        
        function updateCSSConfig() {
            cssConfig.sunSize = parseFloat(document.getElementById('sunSize').value) / 100;
            cssConfig.limitC1Ext = parseFloat(document.getElementById('limitC1Ext').value) / 100;
            cssConfig.limitC1Int = parseFloat(document.getElementById('limitC1Int').value) / 100;
            cssConfig.posC1 = parseInt(document.getElementById('posC1').value) / 100;
            cssConfig.limitC2Ext = parseFloat(document.getElementById('limitC2Ext').value) / 100;
            cssConfig.limitC2Int = parseFloat(document.getElementById('limitC2Int').value) / 100;
            cssConfig.posC2 = parseInt(document.getElementById('posC2').value) / 100;
            cssConfig.ringWidth = parseFloat(document.getElementById('ringWidth').value);
            cssConfig.numberSize = parseFloat(document.getElementById('numberSize').value) / 100;
            cssConfig.opacity = parseInt(document.getElementById('opacitySlider').value) / 100;
            
            // Update display values
            document.getElementById('sunSizeVal').textContent = (cssConfig.sunSize * 100).toFixed(1) + '%';
            document.getElementById('limitC1ExtVal').textContent = (cssConfig.limitC1Ext * 100).toFixed(1) + '%';
            document.getElementById('limitC1IntVal').textContent = (cssConfig.limitC1Int * 100).toFixed(1) + '%';
            document.getElementById('posC1Val').textContent = Math.round(cssConfig.posC1 * 100) + '%';
            document.getElementById('limitC2ExtVal').textContent = (cssConfig.limitC2Ext * 100).toFixed(1) + '%';
            document.getElementById('limitC2IntVal').textContent = (cssConfig.limitC2Int * 100).toFixed(1) + '%';
            document.getElementById('posC2Val').textContent = Math.round(cssConfig.posC2 * 100) + '%';
            document.getElementById('ringWidthVal').textContent = cssConfig.ringWidth.toFixed(1) + 'px';
            document.getElementById('numberSizeVal').textContent = (cssConfig.numberSize * 100).toFixed(2) + '%';
            document.getElementById('opacityVal').textContent = Math.round(cssConfig.opacity * 100) + '%';
            
            applyAllCSS();
        }
        
        function applyAllCSS() {
            for (var m = 0; m < 2; m++) {
                // Sun size
                var sun = document.getElementById('sunReactor' + (m + 1));
                var sunDiameter = cssConfig.sunSize * 100;
                sun.style.width = sunDiameter + '%';
                sun.style.height = sunDiameter + '%';
                
                // Update rings
                updateRings(m);
                
                // Update number sizes
                for (var c = 0; c < 2; c++) {
                    for (var i = 0; i < matrices[m].data[c].length; i++) {
                        if (matrices[m].data[c][i].elem) {
                            var size = cssConfig.numberSize * matrices[m].canvasSize;
                            matrices[m].data[c][i].elem.style.width = size + "px";
                            matrices[m].data[c][i].elem.style.height = size + "px";
                            matrices[m].data[c][i].elem.style.fontSize = (size * 0.45) + "px";
                        }
                    }
                }
                
                updateAllPositions(m);
            }
        }
        
        function updateSunVisibility() {
            var show = document.getElementById('showSun').checked;
            document.getElementById('sunReactor1').classList.toggle('visible', show);
            document.getElementById('sunReactor2').classList.toggle('visible', show);
        }
        
        function updateRingsVisibility() {
            var show = document.getElementById('showRings').checked;
            document.querySelectorAll('.ring').forEach(function(r) {
                r.style.display = show ? 'block' : 'none';
            });
        }
        
        function initAudio() { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
        function playTick() { if (!audioCtx) return; var o = audioCtx.createOscillator(), g = audioCtx.createGain(); o.connect(g); g.connect(audioCtx.destination); o.frequency.value = 800; o.type = 'sine'; g.gain.setValueAtTime(0.3, audioCtx.currentTime); g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.05); o.start(audioCtx.currentTime); o.stop(audioCtx.currentTime + 0.05); }
        function playExchange() { if (!audioCtx) return; var o = audioCtx.createOscillator(), g = audioCtx.createGain(); o.connect(g); g.connect(audioCtx.destination); o.frequency.value = 523; o.type = 'triangle'; g.gain.setValueAtTime(0.4, audioCtx.currentTime); g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3); o.start(audioCtx.currentTime); o.stop(audioCtx.currentTime + 0.3); }
        
        function togglePlay() { isPlaying = !isPlaying; var btn = document.getElementById("playBtn"); btn.textContent = isPlaying ? "Pause" : "Play"; btn.classList.toggle("active", isPlaying); if (isPlaying) runAnimation(); else if (animationId) { cancelAnimationFrame(animationId); animationId = null; } }
        function runAnimation() { if (!isPlaying) return; matrices[0].globalRotation += speed; matrices[1].globalRotation -= speed; updateAllPositions(0); updateAllPositions(1); animationId = requestAnimationFrame(runAnimation); }
        
        function updateDimensions(m) { 
            var ga = document.getElementById("gameArea" + (m + 1)); 
            var rect = ga.getBoundingClientRect(); 
            matrices[m].canvasSize = rect.width; 
            matrices[m].cx = rect.width / 2; 
            matrices[m].cy = rect.width / 2; 
            var canvas = document.getElementById("triangleCanvas" + (m + 1)); 
            canvas.width = rect.width; 
            canvas.height = rect.width; 
            matrices[m].triangleCtx = canvas.getContext("2d"); 
        }
        
        // Calcul du rayon avec position dans la zone
        function getCrownRadius(m, c) { 
            var limitExt, limitInt, pos;
            if (c === 0) {
                limitExt = cssConfig.limitC1Ext;
                limitInt = cssConfig.limitC1Int;
                pos = cssConfig.posC1;
            } else if (c === 1) {
                limitExt = cssConfig.limitC2Ext;
                limitInt = cssConfig.limitC2Int;
                pos = cssConfig.posC2;
            } else {
                // C3 au centre du soleil
                return (cssConfig.sunSize / 2) * 0.5 * matrices[m].canvasSize;
            }
            
            // Centre de la zone
            var center = (limitExt + limitInt) / 2;
            // Demi-√©paisseur de la zone
            var halfWidth = (limitExt - limitInt) / 2;
            // Position finale : centre + offset (pos va de -1 √† +1)
            var radius = center + (pos * halfWidth * 0.8); // 0.8 pour ne pas toucher les bords
            
            return radius * matrices[m].canvasSize; 
        }
        
        function getCrownSize(m) { return cssConfig.numberSize * matrices[m].canvasSize; }
        function normalize(a) { while(a < 0) a += 360; while(a >= 360) a -= 360; return a; }
        
        function getPositionForCrown(m, crown, index) { 
            var mat = matrices[m]; 
            var angle = (index * crownsConfig[crown].step + crownsConfig[crown].offset + mat.globalRotation + mat.offsets[crown]) * Math.PI / 180; 
            var radius = getCrownRadius(m, crown); 
            return { x: mat.cx + radius * Math.cos(angle), y: mat.cy + radius * Math.sin(angle) }; 
        }
        
        function findTwoNeighbors(m, sommetCrown, sommetIndex, baseCrown) { 
            var mat = matrices[m]; 
            var sommetAngle = normalize(sommetIndex * crownsConfig[sommetCrown].step + crownsConfig[sommetCrown].offset + mat.globalRotation + mat.offsets[sommetCrown]); 
            var neighbors = []; 
            for (var i = 0; i < crownsConfig[baseCrown].count; i++) { 
                var baseAngle = normalize(i * crownsConfig[baseCrown].step + crownsConfig[baseCrown].offset + mat.globalRotation + mat.offsets[baseCrown]); 
                var diff = Math.abs(sommetAngle - baseAngle); 
                if (diff > 180) diff = 360 - diff; 
                neighbors.push({index: i, diff: diff}); 
            } 
            neighbors.sort(function(a, b) { return a.diff - b.diff; }); 
            return [neighbors[0].index, neighbors[1].index]; 
        }
        
        function drawTriangles(m) { 
            var ctx = matrices[m].triangleCtx; 
            if (!ctx) return; 
            var show = document.getElementById("showTriangles").checked; 
            ctx.clearRect(0, 0, matrices[m].canvasSize, matrices[m].canvasSize); 
            if (!show) return; 
            var fillOpacity = cssConfig.opacity * 0.4; 
            var strokeOpacity = cssConfig.opacity; 
            
            // Triangles internes (vers C3/soleil)
            for (var i = 0; i < 5; i++) { 
                var sommet = getPositionForCrown(m, 2, i); 
                var baseIndexes = findTwoNeighbors(m, 2, i, 1); 
                var base1 = getPositionForCrown(m, 1, baseIndexes[0]); 
                var base2 = getPositionForCrown(m, 1, baseIndexes[1]); 
                ctx.beginPath(); 
                ctx.moveTo(base1.x, base1.y); 
                ctx.lineTo(sommet.x, sommet.y); 
                ctx.lineTo(base2.x, base2.y); 
                ctx.closePath(); 
                ctx.fillStyle = "rgba(100, 200, 255, " + fillOpacity + ")"; 
                ctx.fill(); 
                ctx.strokeStyle = "rgba(50, 150, 255, " + strokeOpacity + ")"; 
                ctx.lineWidth = 2; 
                ctx.stroke(); 
            } 
            
            // Triangles externes
            for (var i = 0; i < 10; i++) { 
                var sommet = getPositionForCrown(m, 1, i); 
                var baseIndexes = findTwoNeighbors(m, 1, i, 0); 
                var base1 = getPositionForCrown(m, 0, baseIndexes[0]); 
                var base2 = getPositionForCrown(m, 0, baseIndexes[1]); 
                ctx.beginPath(); 
                ctx.moveTo(base1.x, base1.y); 
                ctx.lineTo(sommet.x, sommet.y); 
                ctx.lineTo(base2.x, base2.y); 
                ctx.closePath(); 
                ctx.fillStyle = "rgba(255, 200, 100, " + (fillOpacity * 0.75) + ")"; 
                ctx.fill(); 
                ctx.strokeStyle = "rgba(255, 180, 50, " + strokeOpacity + ")"; 
                ctx.lineWidth = 2; 
                ctx.stroke(); 
            } 
        }
        
        function updateRings(m) { 
            var ring1 = document.getElementById("ring" + (m + 1) + "_1"); 
            var ring2 = document.getElementById("ring" + (m + 1) + "_2"); 
            var mat = matrices[m]; 
            
            // Ring 1 = limite entre C1 et C2 (= limitC1Int = limitC2Ext normalement)
            var r1 = cssConfig.limitC1Int * mat.canvasSize;
            // Ring 2 = limite entre C2 et soleil (= limitC2Int)
            var r2 = cssConfig.limitC2Int * mat.canvasSize;
            
            ring1.style.width = (r1 * 2) + "px"; 
            ring1.style.height = (r1 * 2) + "px"; 
            ring1.style.borderWidth = cssConfig.ringWidth + "px";
            ring1.style.transform = "translate(-50%, -50%) rotate(" + (-mat.globalRotation) + "deg)"; 
            
            ring2.style.width = (r2 * 2) + "px"; 
            ring2.style.height = (r2 * 2) + "px"; 
            ring2.style.borderWidth = cssConfig.ringWidth + "px";
            ring2.style.transform = "translate(-50%, -50%) rotate(" + (-mat.globalRotation) + "deg)"; 
        }
        
        function applyColor(elem, colorIndex) { 
            if (colorIndex === 0) { elem.style.background = colors.c1bg; elem.style.color = colors.c1txt; } 
            else if (colorIndex === 1) { elem.style.background = colors.c2bg; elem.style.color = colors.c2txt; } 
            else { elem.style.background = colors.c3bg; elem.style.color = colors.c3txt; } 
        }
        
        function createNumber(m, value, crown, index) { 
            var elem = document.createElement("div"); 
            elem.className = "number"; 
            elem.textContent = value; 
            var size = getCrownSize(m); 
            elem.style.width = size + "px"; 
            elem.style.height = size + "px"; 
            elem.style.fontSize = (size * 0.45) + "px"; 
            elem.dataset.matrix = m; 
            elem.dataset.crown = crown; 
            elem.dataset.index = index; 
            applyColor(elem, crown); 
            document.getElementById("gameArea" + (m + 1)).appendChild(elem); 
            return elem; 
        }
        
        function positionNumber(m, elem, crown, index) { 
            var pos = getPositionForCrown(m, crown, index); 
            var size = getCrownSize(m); 
            elem.style.left = (pos.x - size/2) + "px"; 
            elem.style.top = (pos.y - size/2) + "px"; 
        }
        
        function updateAllPositions(m) { 
            var mat = matrices[m]; 
            for (var c = 0; c < 2; c++) { 
                for (var i = 0; i < mat.data[c].length; i++) { 
                    if (mat.data[c][i].elem && !mat.data[c][i].elem.classList.contains('entering-sun')) 
                        positionNumber(m, mat.data[c][i].elem, c, i); 
                } 
            }
            // Positionner les fant√¥mes C3
            for (var i = 0; i < mat.hiddenInSun.length; i++) {
                if (mat.hiddenInSun[i].elem) {
                    var pos = getPositionForCrown(m, 2, i);
                    var size = getCrownSize(m);
                    mat.hiddenInSun[i].elem.style.left = pos.x + "px";
                    mat.hiddenInSun[i].elem.style.top = pos.y + "px";
                    mat.hiddenInSun[i].elem.style.width = size + "px";
                    mat.hiddenInSun[i].elem.style.height = size + "px";
                    mat.hiddenInSun[i].elem.style.fontSize = (size * 0.45) + "px";
                }
            }
            drawTriangles(m); 
            updateRings(m); 
        }
        
        function createDigitPool() { 
            var pool = []; 
            for (var d = 1; d <= 7; d++) for (var i = 0; i < 5; i++) pool.push(d); 
            for (var i = pool.length - 1; i > 0; i--) { 
                var j = Math.floor(Math.random() * (i + 1)); 
                var temp = pool[i]; pool[i] = pool[j]; pool[j] = temp; 
            } 
            return pool; 
        }
        
        function createGhostNumber(m, value, index) { 
            var elem = document.createElement("div"); 
            elem.className = "number ghost"; 
            elem.textContent = value; 
            var size = getCrownSize(m); 
            elem.style.width = size + "px"; 
            elem.style.height = size + "px"; 
            elem.style.fontSize = (size * 0.45) + "px"; 
            elem.dataset.matrix = m; 
            elem.dataset.crown = 2; 
            elem.dataset.index = index;
            // Couleur C3 (orange)
            elem.style.background = colors.c3bg;
            elem.style.color = colors.c3txt;
            // D√©calage al√©atoire de l'animation pour chaque fant√¥me
            elem.style.animationDelay = (Math.random() * 3) + "s";
            document.getElementById("gameArea" + (m + 1)).appendChild(elem); 
            return elem; 
        }
        
        function initMatrix(m) { 
            var ga = document.getElementById("gameArea" + (m + 1)); 
            ga.querySelectorAll(".number").forEach(function(el) { el.remove(); }); 
            updateDimensions(m); 
            matrices[m].data = [[], [], []]; 
            matrices[m].hiddenInSun = [];
            matrices[m].globalRotation = 0; 
            matrices[m].offsets = [0, 0, 0]; 
            var digitPool = createDigitPool(); 
            
            for (var c = 0; c < 2; c++) { 
                for (var i = 0; i < crownsConfig[c].count; i++) { 
                    var val = digitPool.pop(); 
                    var elem = createNumber(m, val, c, i); 
                    matrices[m].data[c].push({ value: val, elem: elem, originColor: c }); 
                } 
            } 
            
            // C3 : 5 chiffres fant√¥mes visibles dans le soleil
            for (var i = 0; i < 5; i++) {
                var val = digitPool.pop();
                var ghostElem = createGhostNumber(m, val, i);
                matrices[m].hiddenInSun.push({ value: val, originColor: 2, elem: ghostElem });
            }
            
            updateRings(m); 
            updateAllPositions(m); 
        }
        
        function resetAll() { initMatrix(0); initMatrix(1); applyAllCSS(); }
        
        function triggerSunWave(m) {
            var sun = document.getElementById("sunReactor" + (m + 1));
            sun.classList.remove('wave');
            void sun.offsetWidth;
            sun.classList.add('wave');
            setTimeout(function() { sun.classList.remove('wave'); }, 500);
        }
        
        function doBlindExchange(m, c2Index, elem) {
            var mat = matrices[m];
            if (mat.hiddenInSun.length === 0) return;
            
            elem.classList.add('entering-sun');
            
            var c2Data = mat.data[1][c2Index];
            var outValue = c2Data.value;
            var outColor = c2Data.originColor;
            
            var sunIndex = Math.floor(Math.random() * mat.hiddenInSun.length);
            var sunData = mat.hiddenInSun[sunIndex];
            
            triggerSunWave(m);
            playExchange();
            
            setTimeout(function() {
                // R√©cup√©rer la valeur du fant√¥me
                var inValue = sunData.value;
                var inColor = sunData.originColor;
                
                // Mettre √† jour le chiffre C2 avec la valeur du soleil
                c2Data.value = inValue;
                c2Data.originColor = inColor;
                c2Data.elem.textContent = inValue;
                applyColor(c2Data.elem, inColor);
                
                // Mettre √† jour le fant√¥me avec la valeur qui entre
                sunData.value = outValue;
                sunData.originColor = outColor;
                if (sunData.elem) {
                    sunData.elem.textContent = outValue;
                    applyColor(sunData.elem, outColor);
                }
                
                elem.classList.remove('entering-sun');
                updateAllPositions(m);
            }, 250);
        }
        
        // === MULTITOUCH ===
        function setupGameTouch() {
            var gameAreas = document.querySelectorAll('.game-area');
            gameAreas.forEach(function(ga) { ga.addEventListener('touchstart', handleGameTouchStart, {passive: false}); });
            document.addEventListener('touchmove', handleGameTouchMove, {passive: false});
            document.addEventListener('touchend', handleGameTouchEnd);
            document.addEventListener('touchcancel', handleGameTouchEnd);
            gameAreas.forEach(function(ga) { ga.addEventListener('mousedown', handleMouseDown); });
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
        }
        
        function handleGameTouchStart(e) { initAudio(); for (var i = 0; i < e.changedTouches.length; i++) { var touch = e.changedTouches[i]; var target = document.elementFromPoint(touch.clientX, touch.clientY); handleTouchStart(touch.identifier, touch.clientX, touch.clientY, target); } e.preventDefault(); }
        function handleGameTouchMove(e) { for (var i = 0; i < e.changedTouches.length; i++) { var touch = e.changedTouches[i]; if (activeTouches[touch.identifier]) { handleTouchMove(touch.identifier, touch.clientX, touch.clientY); e.preventDefault(); } } }
        function handleGameTouchEnd(e) { for (var i = 0; i < e.changedTouches.length; i++) { handleTouchEnd(e.changedTouches[i].identifier); } }
        function handleMouseDown(e) { handleTouchStart('mouse', e.clientX, e.clientY, e.target); }
        function handleMouseMove(e) { if (activeTouches['mouse']) handleTouchMove('mouse', e.clientX, e.clientY); }
        function handleMouseUp() { handleTouchEnd('mouse'); }

        function findMatrixFromPoint(x, y) { for (var m = 0; m < 2; m++) { var ga = document.getElementById("gameArea" + (m + 1)); var rect = ga.getBoundingClientRect(); if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) return m; } return -1; }
        
        function getCrownZones(m) { 
            var size = matrices[m].canvasSize;
            // Zone C1 : entre le bord du cercle (50%) et la position des chiffres C1
            var c1ChiffresRadius = getCrownRadius(m, 0);
            var c1GrabOuter = size * 0.5;
            var c1GrabInner = c1ChiffresRadius + (cssConfig.numberSize * size / 2);
            
            // Zone C2 : entre l'anneau 1 (limitC1Int) et la position des chiffres C2
            var c2ChiffresRadius = getCrownRadius(m, 1);
            var c2GrabOuter = cssConfig.limitC1Int * size;
            var c2GrabInner = c2ChiffresRadius + (cssConfig.numberSize * size / 2);
            
            return [
                {outer: c1GrabOuter, inner: c1GrabInner},
                {outer: c2GrabOuter, inner: c2GrabInner}
            ]; 
        }
        
        function handleTouchStart(id, clientX, clientY, target) { 
            var m = findMatrixFromPoint(clientX, clientY); 
            if (m < 0) return; 
            var ga = document.getElementById("gameArea" + (m + 1)); 
            var rect = ga.getBoundingClientRect(); 
            var x = clientX - rect.left; 
            var y = clientY - rect.top; 
            var mat = matrices[m]; 
            var relX = x - mat.cx; 
            var relY = y - mat.cy; 
            var dist = Math.sqrt(relX * relX + relY * relY); 
            
            if (target && target.classList && target.classList.contains('number')) { 
                var crown = parseInt(target.dataset.crown); 
                var index = parseInt(target.dataset.index); 
                var matrix = parseInt(target.dataset.matrix); 
                activeTouches[id] = { 
                    type: 'triangle', 
                    matrix: matrix, 
                    active: true, 
                    crown: crown, 
                    index: index, 
                    startX: x, 
                    startY: y, 
                    directionDecided: false, 
                    element: target, 
                    currentDelta: 0 
                }; 
                target.classList.add('dragging'); 
                return; 
            } 
            
            var targetCrown = -1; 
            var crownZones = getCrownZones(m); 
            for (var c = 0; c < 2; c++) {
                if (dist <= crownZones[c].outer && dist >= crownZones[c].inner) { 
                    targetCrown = c; 
                    break; 
                } 
            } 
            if (targetCrown >= 0) { 
                activeTouches[id] = { type: 'crown', matrix: m, isDragging: true, crown: targetCrown, startAngle: Math.atan2(relY, relX) * 180 / Math.PI, startOffset: mat.offsets[targetCrown] }; 
            } 
        }
        
        function handleTouchMove(id, clientX, clientY) { 
            var touchData = activeTouches[id]; 
            if (!touchData) return; 
            var m = touchData.matrix; 
            var ga = document.getElementById("gameArea" + (m + 1)); 
            var rect = ga.getBoundingClientRect(); 
            var x = clientX - rect.left; 
            var y = clientY - rect.top; 
            var mat = matrices[m]; 
            
            if (touchData.type === 'crown') { 
                var relX = x - mat.cx; 
                var relY = y - mat.cy; 
                var angle = Math.atan2(relY, relX) * 180 / Math.PI; 
                var oldOffset = mat.offsets[touchData.crown]; 
                var newOffset = touchData.startOffset + (angle - touchData.startAngle); 
                var step = crownsConfig[touchData.crown].step; 
                if (Math.round(oldOffset / step) !== Math.round(newOffset / step)) playTick(); 
                mat.offsets[touchData.crown] = newOffset; 
                updateAllPositions(m); 
            } else if (touchData.type === 'triangle') { 
                doTriangleDrag(touchData, x, y, m); 
            } 
        }
        
        function handleTouchEnd(id) { 
            var touchData = activeTouches[id]; 
            if (!touchData) return; 
            var m = touchData.matrix; 
            var mat = matrices[m]; 
            
            if (touchData.type === 'crown') { 
                var c = touchData.crown; 
                var step = crownsConfig[c].step; 
                var targetOffset = Math.round(mat.offsets[c] / step) * step; 
                var startOffset = mat.offsets[c]; 
                var startTime = performance.now(); 
                function animSnap(t) { 
                    var p = Math.min((t - startTime) / 150, 1); 
                    mat.offsets[c] = startOffset + (targetOffset - startOffset) * (1 - Math.pow(1 - p, 3)); 
                    updateAllPositions(m); 
                    if (p < 1) requestAnimationFrame(animSnap); 
                    else mat.offsets[c] = targetOffset; 
                } 
                requestAnimationFrame(animSnap); 
            } else if (touchData.type === 'triangle') { 
                endTriangleDrag(touchData, m); 
            } 
            delete activeTouches[id]; 
        }
        
        function lerp(a, b, t) { return { x: a.x + (b.x - a.x) * t, y: a.y + (b.y - a.y) * t }; }
        function posOnTriangle(tri, t) { var tt = ((t % 1) + 1) % 1; var side = tt * 3; var i = Math.floor(side); if (i >= 3) i = 2; var frac = side - i; return lerp(tri[i], tri[(i + 1) % 3], frac); }
        function nearestParamOnTriangle(tri, x, y) { var bestT = 0, bestDist = Infinity; for (var tt = 0; tt < 1; tt += 0.005) { var p = posOnTriangle(tri, tt); var d = (x - p.x) * (x - p.x) + (y - p.y) * (y - p.y); if (d < bestDist) { bestDist = d; bestT = tt; } } return bestT; }
        function getTriangleData(m, type, index) { var vertices, points; if (type === 'outer') { var baseIndexes = findTwoNeighbors(m, 1, index, 0); vertices = [{crown: 1, index: index},{crown: 0, index: baseIndexes[0]},{crown: 0, index: baseIndexes[1]}]; } points = vertices.map(function(v) { return getPositionForCrown(m, v.crown, v.index); }); return {vertices: vertices, points: points}; }
        
        function doTriangleDrag(touchData, x, y, m) { 
            if (!touchData.active) return; 
            var mat = matrices[m]; 
            var dx = x - touchData.startX; 
            var dy = y - touchData.startY; 
            var dist = Math.sqrt(dx*dx + dy*dy); 
            
            if (!touchData.directionDecided && dist > 10) { 
                var startDist = Math.sqrt(Math.pow(touchData.startX - mat.cx, 2) + Math.pow(touchData.startY - mat.cy, 2)); 
                var currentDist = Math.sqrt(Math.pow(x - mat.cx, 2) + Math.pow(y - mat.cy, 2)); 
                var goingInward = currentDist < startDist;
                
                if (touchData.crown === 1 && goingInward) {
                    touchData.triangleType = 'sunExchange';
                    touchData.directionDecided = true;
                    return;
                }
                
                if (touchData.crown === 0) { 
                    touchData.triangleType = 'outer'; 
                    for (var i = 0; i < 10; i++) { 
                        var baseIndexes = findTwoNeighbors(m, 1, i, 0); 
                        if (baseIndexes[0] === touchData.index || baseIndexes[1] === touchData.index) { 
                            touchData.triangleIndex = i; 
                            break; 
                        } 
                    } 
                } else if (touchData.crown === 1 && !goingInward) { 
                    touchData.triangleType = 'outer'; 
                    touchData.triangleIndex = touchData.index; 
                }
                
                if (touchData.triangleType === 'outer') { 
                    touchData.directionDecided = true; 
                    touchData.triData = getTriangleData(m, 'outer', touchData.triangleIndex); 
                    touchData.initialTs = [0, 1/3, 2/3]; 
                    touchData.startMouseT = nearestParamOnTriangle(touchData.triData.points, touchData.startX, touchData.startY); 
                } 
            } 
            
            if (touchData.directionDecided && touchData.triangleType === 'outer' && touchData.triData) { 
                var triData = touchData.triData; 
                var newMouseT = nearestParamOnTriangle(triData.points, x, y); 
                var delta = newMouseT - touchData.startMouseT; 
                for (var v = 0; v < 3; v++) { 
                    var t = ((touchData.initialTs[v] + delta) % 1 + 1) % 1; 
                    var vert = triData.vertices[v]; 
                    var pos = posOnTriangle(triData.points, t); 
                    var elem = mat.data[vert.crown][vert.index].elem; 
                    var size = getCrownSize(m); 
                    elem.style.left = (pos.x - size/2) + "px"; 
                    elem.style.top = (pos.y - size/2) + "px"; 
                } 
                touchData.currentDelta = delta; 
            }
            
            if (touchData.triangleType === 'sunExchange') {
                var elem = touchData.element;
                var size = getCrownSize(m);
                var startPos = getPositionForCrown(m, touchData.crown, touchData.index);
                
                var totalDist = Math.sqrt(Math.pow(startPos.x - mat.cx, 2) + Math.pow(startPos.y - mat.cy, 2));
                var currentDistFromStart = Math.sqrt(Math.pow(x - touchData.startX, 2) + Math.pow(y - touchData.startY, 2));
                var progress = Math.min(currentDistFromStart / (totalDist * 0.5), 1);
                
                var newX = startPos.x + (mat.cx - startPos.x) * progress;
                var newY = startPos.y + (mat.cy - startPos.y) * progress;
                elem.style.left = (newX - size/2) + "px";
                elem.style.top = (newY - size/2) + "px";
                
                var distFromCenter = Math.sqrt(Math.pow(newX - mat.cx, 2) + Math.pow(newY - mat.cy, 2));
                var sunRadius = (cssConfig.sunSize / 2) * mat.canvasSize;
                if (distFromCenter < sunRadius) {
                    elem.classList.add('entering-sun');
                } else {
                    elem.classList.remove('entering-sun');
                }
                
                touchData.exchangeProgress = progress;
            }
        }
        
        function endTriangleDrag(touchData, m) { 
            if (!touchData.active) return; 
            var mat = matrices[m]; 
            if (touchData.element) touchData.element.classList.remove('dragging'); 
            
            if (touchData.triangleType === 'sunExchange') {
                if (touchData.exchangeProgress > 0.6) {
                    doBlindExchange(m, touchData.index, touchData.element);
                } else {
                    touchData.element.classList.remove('entering-sun');
                    updateAllPositions(m);
                }
                touchData.active = false;
                return;
            }
            
            if (touchData.triangleType === 'outer' && touchData.triData && touchData.currentDelta !== undefined) { 
                var delta = touchData.currentDelta; 
                var triData = touchData.triData; 
                if (Math.abs(delta) > 0.05) { 
                    var shift = delta > 0 ? 1 : -1; 
                    var oldValues = [], oldColors = []; 
                    for (var v = 0; v < 3; v++) { 
                        var vert = triData.vertices[v]; 
                        oldValues.push(mat.data[vert.crown][vert.index].value); 
                        oldColors.push(mat.data[vert.crown][vert.index].originColor); 
                    } 
                    for (var v = 0; v < 3; v++) { 
                        var sourceV = ((v - shift) % 3 + 3) % 3; 
                        var vert = triData.vertices[v]; 
                        mat.data[vert.crown][vert.index].value = oldValues[sourceV]; 
                        mat.data[vert.crown][vert.index].originColor = oldColors[sourceV]; 
                        mat.data[vert.crown][vert.index].elem.textContent = oldValues[sourceV]; 
                        applyColor(mat.data[vert.crown][vert.index].elem, oldColors[sourceV]); 
                    } 
                    playTick(); 
                } 
            } 
            updateAllPositions(m); 
            touchData.active = false; 
        }
        
        function handleResize() { 
            for (var m = 0; m < 2; m++) { 
                updateDimensions(m); 
                applyAllCSS();
            } 
        }
        window.addEventListener('resize', handleResize);
        window.addEventListener('orientationchange', function() { setTimeout(handleResize, 100); });
        
        // Shuffle des fant√¥mes - m√©lange les valeurs dans le soleil r√©guli√®rement
        function shuffleGhosts(m) {
            var mat = matrices[m];
            if (mat.hiddenInSun.length < 2) return;
            
            // M√©langer les valeurs entre les fant√¥mes
            var values = mat.hiddenInSun.map(function(g) { return g.value; });
            // Fisher-Yates shuffle
            for (var i = values.length - 1; i > 0; i--) {
                var j = Math.floor(Math.random() * (i + 1));
                var temp = values[i];
                values[i] = values[j];
                values[j] = temp;
            }
            // R√©assigner
            for (var i = 0; i < mat.hiddenInSun.length; i++) {
                mat.hiddenInSun[i].value = values[i];
                if (mat.hiddenInSun[i].elem) {
                    mat.hiddenInSun[i].elem.textContent = values[i];
                }
            }
        }
        
        // Lancer le shuffle p√©riodique
        setInterval(function() {
            shuffleGhosts(0);
            shuffleGhosts(1);
        }, 1500);
        
        setupGameTouch();
        initMatrix(0);
        initMatrix(1);
        updateCSSConfig(); // Initialize display values
        applyAllCSS();
    </script>
</body>
</html>
